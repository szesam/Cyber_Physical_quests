# Quest Name
Authors: Carmen Hurtado , Samuel Sze, Hazim Halim

Date: 2021-04-29
-----

## Summary
**Contributors:**
Samuel | Carmen | Hazim


In this quest we designed a semi-autonomous crawler which has the ability for cruise control as well as being controlled by a user through a web page.
To achieve this, we have attached the following onto the crawler: 
    1) LIDAR
    2) Encoder
    3) Accelerometer
    4) (Place for ultrasonic)
    5) PID
Once turned on, the crawler will begin to move when it detects that there are no obstacle within 20 cm of it. It will maintain a speed of 2 cm/sec using PID. If the LIDAR detects an obstacle within 1 meter, it will send a warning to the webpage. If the obstacle comes within 20 CM of the crawler, it will automatically stop and send a message to the webpage prompting the next course of action

## Self-Assessment

### Objective Criteria

| Objective Criterion | Rating | Max Value  | 
|---------------------------------------------|:-----------:|:---------:|
| Objective One |  |  1     | 
| Objective Two |  |  1     | 
| Objective Three |  |  1     | 
| Objective Four |  |  1     | 
| Objective Five |  |  1     | 
| Objective Six |  |  1     | 
| Objective Seven |  |  1     | 


### Qualitative Criteria

| Qualitative Criterion | Rating | Max Value  | 
|---------------------------------------------|:-----------:|:---------:|
| Quality of solution |  |  5     | 
| Quality of report.md including use of graphics |  |  3     | 
| Quality of code reporting |  |  3     | 
| Quality of video presentation |  |  3     | 


## Solution Design
Front End and UDP Protocol Communication:
For this quest we are asked to set up a web page through a web server in which a user can control the motion of the crawler. Not only do the user get to start, stop, and steer the crawler, but the page also displays data back to the user. This data includes distance traveled, calculated using an Optical Encoder. It also includes crawler speed calculated using two different devices, the previoulsy mentioned optical encoder and an ADXL343 accelerometer.
We have set up the communication between the ESP32 and the server using UDP protocol through a Wifi generated by the Loaned Router. Using UDP we send a payload that includes the sensor data and it is transmitted every one second. At the server side, we receive this message and we transfer the separated data to the web page using SocketIO. This transmission happens every one second, and therefore information in the web page is updated every one second. 
The web page features 4 buttons. START BUGGY, STOP BUGGY, STEER RIGHT, STEER LEFT. Once one of these buttons is pressed, a message is sent back to the udp client(ESP32) and the Crawler acts accordingly. 


### Crawler Build and Circuitry:

On top of the base-design crawler, we attached  a breadboard using some zipties so that it secured in place even if the crawler is moving. 
The breadboard contains the circuits connecting the 


## Sketches and Photos
<center><img src="./images/ece444.png" width="25%" /></center>  
<center> </center>


## Supporting Artifacts
- [Link to video demo](). Not to exceed 120s


## Modules, Tools, Source Used Including Attribution
- ESP32
- Lidar Lite V3
- IR range finder 
- ADC
- I2C
- Optical Encoder 
- ADXL343
- RaspberryPi Camera
- Alphanumeric Display
- UDP 
- Node Js
- SocketIO
## References

-----

